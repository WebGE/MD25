<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8' />
	<meta http-equiv="X-UA-Compatible" content="chrome=1" />
	<meta name="description" content="Contrôler deux motoréducteurs équipés d'encodeurs avec une carte MD25 : Programme de test en C# et description de la classe MD25"
	/>
	<link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
	<title>MD25</title>
</head>

<body>

	<!-- HEADER -->
	<div id="header_wrap" class="outer">
		<header class="inner">
			<a id="forkme_banner" href="https://github.com/WebGE/MD25">View on GitHub</a>
			<h1 id="project_title">MD25 - Dual 12Volt 2.8Amp H Bridge Motor Drive </h1>
			<h2 id="project_tagline">Description de la classe <strong><em>MD25</em></strong> développée en C# sous .NETMF 4.3 pour les cartes Netduino et FEZ
				(PANDA, COBRA...)</h2>
			<section id="downloads">
				<a class="zip_download_link" href="https://github.com/WebGE/MD25/zipball/master">Download this project as a .zip file</a>
				<a class="tar_download_link" href="https://github.com/WebGE/MD25/tarball/master">Download this project as a tar.gz file</a>
			</section>
		</header>
	</div>

	<!-- MAIN CONTENT -->
	<div id="main_content_wrap" class="outer">
		<section id="main_content" class="inner">
			<hr>
			<h4>Sommaire</h4>
			<ol>
				<li>LE MATERIEL
					<ol>
						<li>La carte MD25 - Dual 12Volt 2.8Amp H Bridge Motor Drive</li>
						<li><a href="#DUINO">Les cartes Netduino</a></li>
						<li><a href="#FEZ">Les cartes FEZ</a> </li>
					</ol>
				</li>
				<li><a href="#LOG">LE LOGICIEL</a>
					<ol>
						<li><a href="#REP">Contenu du répertoire proposé au téléchargement</a></li>
						<li><a href="#NUGET">Le NuGet MicroToolsKit</a></li>
						<li><a href="#WIKI">Les Wikis</a></li>
						<li><a href="#DESC">Description et utilisation de la classe MD25</a></li>
					</ol>
				</li>
			</ol>
			<hr>
			<h3>1. LE MATERIEL</h3>
			<hr>
			<h4>1.1 La carte MD25 - Dual 12Volt 2.8Amp H Bridge Motor Drive</h4>
			<hr>
			<ul>
				<li><strong>Présentation</strong></li>
				<p>Destinée à être commandée par un microcontrôleur au moyen d'une liaison série (niveau logique 0 - 5 V) ou via un <strong>bus I2C™</strong>,
					cette platine électronique intègre un <strong>double pont en "H"</strong> permettant le pilotage indépendant de <strong>2 moteurs à courant continu avec encodeur</strong>					(consommation: 2,5 A max. par moteur).<br> Des ordres simples permettent de définir le sens de rotation ainsi que la
					vitesse des moteurs, de lire les informations en provenance des encodeurs, de lire les valeurs de la tension et du courant
					consommé par les moteurs, de connaître leur vitesse de rotation, de définir les accélérations, etc...</p>
				<p align="center"><img src="images/md25connection.png"></p>
				<li><strong>Alimentation :</strong> 12 Vcc (un régulateur 5 Vcc intégré délivre 300 mA pour l’électronique de commande externe).</li>
				<li><strong>Possibilités: </strong>Plusieurs platines peuvent être pilotées en même temps via un bus I2C™</li>
				<li><strong>Dimensions:</strong> 70 x 60 x 25 mm.</li>
				<li><strong>Documentation :</strong> <a href="http://www.pishrobot.com/files/products/datasheets/md25.pdf" target="_blank">MD25 - Dual 12Volt 2.8Amp H Bridge Motor Drive</a></li>
				<li><strong>Distributeur :</strong> <a href="http://www.lextronic.fr/P3104-module-de-commande-de-moteur-md25.html" target="_blank">Lextronic</a></li>
			</ul>
			<hr>

			<h4 id="DUINO">1.2 Les cartes Netduino</h4>
			<h5>Secret Labs</h5>
			<hr>
			<ul>
				<li><strong>Microcontrôleur</strong> : STM32F405RG 32 bits à architecture Cortex-M4 cadencé à 168 MHz.</li>
				<li><strong>RAM</strong> : 164KB+.</li>
				<li><strong>Flash</strong> : 1408KB.</li>
				<li><strong>Port Ethernet : </strong> 10/100Mbps (Wifi:802.11b/g/n)*.</li>
				<li><strong>E/S numériques</strong> : 22</li>
				<li><strong>Entrées analogiques</strong> : 6</li>
				<li><strong>Stockage</strong>: carte µSD</li>
				<li><strong>IDE</strong> : Microsoft Visual Studio</li>
				<li><strong>Framework</strong> : .NETMF 4.3</li>
				<li><strong>Langages de programmation</strong> : C#, VB</li>
				<li><strong>Compatibilité</strong> : shield Arduino, Gadgeteer</li>
			</ul>
			<table>
				<tr>
					<td><img src="images/netduino3ethernet.png" alt="Netduino plus 2" target="_blank" /></td>
					<td><img src="images/inputandoutput.png" alt="Netduino 3 wifi" target="_blank" /></td>
				</tr>
				<tr>
					<td align="center"><strong>Netduino 3 Ethernet</strong></td>
					<td align="center"><strong>Netduino 3 wifi*</strong></td>
				</tr>
			</table>

			<ul>
				<li><strong>Sites à consulter</strong> : <a href="http://netduino.com/netduinoplus2/specs.htm" target="_blank">Netduino</a>,
					<a href="http://www.netmf.com/" target="_blank">NETMF</a></li>
				<li><strong>Distributeurs</strong> : <a href="http://www.mouser.fr/Search/Refine.aspx?Keyword=netduino" target="_blank">Mouser Electronics</a></li>
			</ul>
			<hr>

			<h4 id="FEZ">
				<a name="carte-netduino-de-secret-labs" class="anchor" href="#carte-netduino-de-secret-labs" target="_blank">
					<span class="octicon octicon-link"></span></a>1.3 Les cartes FEZ</h4>
			<h5>GHI Electonics (Extrait)</h5>
			<hr>
			<ul>
				<li><strong>Microcontrôleur</strong> : 180 MHz 32-bit ARM Cortex-M4.(120 MHz 32-bit ARM Cortex-M3 )*</li>
				<li><strong>SoC(SoM)*</strong> : <a href="https://www.ghielectronics.com/catalog/product/501" target="_blank">G80</a>
					<a href="https://www.ghielectronics.com/catalog/product/373" target="_blank">G120*</a>
				</li>
				<li><strong>RAM</strong> : 156 KB(2.87 MB)*.</li>
				<li><strong>Flash</strong> : 256 KB (13.67 MB)*.</li>
				<li><strong>E/S numériques</strong> : 53(60)*</li>
				<li><strong>Entrées analogiques</strong> : 16(8)*</li>
				<li><strong>Réseaux : </strong> Ethernet TCP/IP, WiFi, and SSL.</li>
				<li><strong>Stockage</strong>: carte µSD</li>
				<li><strong>IDE</strong> : Microsoft Visual Studio</li>
				<li><strong>Framework</strong> : .NETMF 4.3</li>
				<li><strong>Langages de programmation</strong> : C#, VB</li>
			</ul>

			<table>
				<tr>
					<td><img src="images/panda3.png" alt="PANDA III" /></td>
					<td><img src="images/cobra3.png" alt="COBRA III" /></td>
				</tr>
				<tr>
					<td align="center"><strong>PANDA III</strong></td>
					<td align="center"><strong>COBRA III* (compatible Gadgeteer)</strong></td>
				</tr>
			</table>

			<ul>
				<li><strong>Sites à consulter</strong> : <a href="https://www.ghielectronics.com/" target="_blank">GHI ELECTRONICS</a>,
					<a href="http://www.netmf.com/" target="_blank">NETMF</a></li>
				<li><strong>Distributeurs</strong> : <a href="http://www.mouser.fr" target="_blank">Mouser Electronics</a></li>
			</ul>

			<hr>
			<h3 id="LOG">2. LE LOGICIEL</h3>
			<hr>

			<h4 id="REP">2.1 Contenu du répertoire proposé au téléchargement</h4>
			<p>Le répertoire proposé au téléchargement (au format zip ou tar.gz) contient la solution <strong>NetduinoMD25</strong> composée:</p>
			<ul>
				<li>Du projet <strong>MD25 </strong>: le <strong>code source</strong> de la classe <em>MotorControlMD2x</em>.</li>
				<li>Du projet <strong>Netduino </strong>: un exemple d'utilisation de cette classe avec une carte Netduino.</li>
				<li>Du projet <strong>FezPanda </strong>: un exemple d'utilisation de cette classe avec une carte Panda.</li>
			</ul>
			<hr>

			<h4 id="NUGET">2.2 Le NuGet MicroToolsKit</h4>
			<p>La dernière version <strong>compilée</strong> de la classe <strong>MotorControlMD2x</strong> se situe dans la bibliothèque
				<strong>MicroToolsKit</strong> disponible sur <a href="https://www.nuget.org/packages/WebGE.MicroToolsKit/" target="_blank">nuget.org</a>.</p>
			<p align="center"><img src="images/NuGet-large.png" /></p>
			<p><strong>Organisation des classes</strong> contenues dans MicroToolsKit <a href="https://csharpembarquenetduino.wikispaces.com/6.+La+biblioth%C3%A8que+MicroToolsKit"
				 target="_blank">[lien]</a></p>
			<p><em><strong>Important</strong> : Installer ce nuget dans le projet Visual Studio simplifie l'utilisation de la classe.</em></p>
			<hr>

			<h4 id="WIKI">2.3 Les Wikis</h4>
			<ul>
				<li><strong>Fascicules</strong> d'exemples de code pour les cartes <strong>Netduino</strong>. <a href="https://csharpembarquenetduino.wikispaces.com/5a.+Les+fascicules+d%27exemples++cod%C3%A9s+en+CSharp+pour+la+carte+Netduino"
					 target="_blank">[lien]</a></li>
				<li><strong>Fascicule</strong> d'exemples de code pour les cartes <strong>FEZ</strong>. <a href="https://csharpembarquenetduino.wikispaces.com/5b.+Le+fascicule+d%27exemples++cod%C3%A9s+en+CSharp+pour+les+cartes+Fez"
					 target="_blank">[lien]</a></li>
			</ul>
			<hr>

			<h4 id="DESC">2.4 Description et utilisation de la classe MD2x</h4>
			<ul>
				<li><strong>Rôle: </strong>Contrôler deux motoréducteurs équipés d'un encodeur via le bus I²C.</li>
				<li><strong>Assembly: </strong> <em>MicroToolsKit</em> (disponible sur
					<a href="https://www.nuget.org/packages/WebGE.MicroToolsKit/" target="_blank">nuget.org</a>)</li>
				<li><strong>Espace de noms: </strong><em>Microtoolskit.Hardware.MotorDrivers</em></li>
			</ul>

			<hr/>
			<p><strong>Création d'un projet avec l'IDE Visual Studio</strong></p>
			<ol>
				<li><strong>Créer </strong>un nouveau projet en suivant la démarche décrite dans le chapitre <em>"Premier programme en C# étape par étape"</em>					du Wiki dédié à une carte <strong>Netduino</strong> ou du Wiki dédié à une carte <strong>Fez. </strong>Ces Wikis sont
					accessibles
					<a href="https://csharpembarquenetduino.wikispaces.com/6.+MicroToolsKit+library" target="_blank">ici</a>.</li>
				<li><strong>Utiliser</strong> le gestionnaire de paquets NuGet pour <strong>ajouter</strong> la bibliothèque <strong>MicroToolsKit</strong>					(
					<a href="https://www.nuget.org/packages/WebGE.MicroToolsKit/ " target="_blank ">nuget.org</a>) dans le projet. (Dans
					l'explorateur de solution, clic droit sur les <em>Références</em> du projet puis choisir <em>Gérer les packages NuGet...</em>.<strong> Installer</strong>					le paquet.)</li>
				<li><strong>Ajouter</strong> l'espace de noms <strong>Microtoolskit.Hardware.MotorDrivers</strong> dans l'en-tête du fichier
					source.
				</li>
				<li><strong>Créer</strong> un objet en utilisant un des constructeurs MotorControlMD2x.</li>
				<li><strong>Régler</strong> la fréquence de rotation des moteurs avec la méthode <strong>SetSpeedTurn.</strong></li>
				<li><strong>etc...</strong></li>
			</ol>
			<hr>
			<p><strong>Exemple</strong></p>
			<pre>
using System;
using System.Threading;
using Microsoft.SPOT;

using Microtoolskit.Hardware.MotorDrivers;

namespace NetduinoMD25
{
	public class Program
	{
		public static void Main()
		{   
			var MD25 = new MotorControlMD2x();

			// Pour info : Lecture des registres de la carte MD2x et affichage de la version du logiciel
			Debug.Print("Vers.=" + MD25.SoftRev.ToString());
			Debug.Print("Tension=" + ((Single)MD25.Battery / 10).ToString("N1") + "V");
			Debug.Print("Acceleration=" + MD25.AccelerationRate.ToString());
			Debug.Print("Mode=" + MD25.Mode.ToString());

			while (true)
			{
				// Essai : Rotation des moteurs jusqu'à ce que la distance recherchée soit atteinte
				// ---------------------------------------------------------------------
				MD25.RazEncoders(); // Remise à zéro des codeurs
				MD25.SetSpeedTurn(140, 140); // Réglage de la vitesse des moteurs

				while (MD25.Encoder1 < 2000)
				{
					Debug.Print("Codeur 1=" + MD25.Encoder1.ToString() + " " + "Codeur 2=" + MD25.Encoder2.ToString() +
					 " Speed1=" + MD25.Speed1.ToString() + " Speed2=" + MD25.Speed2Turn.ToString());
				}
				MD25.StopMotor();  // Arrêt des moteurs
				Thread.Sleep(5000);
			}          
		}
	}
}
      		</pre>
			<hr>
			<p><strong>Constructeurs</strong></p>
			<table>
				<tr>
					<td></td>
					<td><strong>Syntaxe</strong></td>
					<td><strong>Description</strong></td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>MotorControlMD2x()</strong></td>
					<td>Instancie un objet "carte MD25". <br> <strong>SLA</strong> = 0x58 (par défaut). <br><strong>Frequency</strong> : fréquence
						du bus I²C = 100kHz (par défaut) <br><br>
						<strong>Exemple</strong><br>
						<em>var MD25 = new MotorControlMD2x();</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>MotorControlMD2x</strong>(<strong>UInt16</strong> <em>SLA</em>)</td>
					<td>Instancie un objet "carte MD25". <br><strong>SLA</strong>: à définir dans l'intervalle [0x58,0x5F]. <br><strong>Frequency</strong>:
						fréquence du bus I²C = 100kHz<br><br>
						<strong>Exemple</strong><br>
						<em>var MD25 = new MotorControlMD2x(0x59);</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>MotorControlMD2x</strong>(<strong>UInt16</strong> <em>SLA</em>, <strong>UInt16</strong> <em>Frequency</em>)</td>
					<td>Instancie un objet "carte MD25". <br> <strong>SLA</strong>: à définir dans l'intervalle [0x58,0x5F]. <br><strong>Frequency</strong>:
						fréquence du bus I²C à définir dans l'intervalle [100kHz,400kHz]. <br><br>
						<strong>Exemple</strong><br>
						<em>var MD25 = new MotorControlMD2x(0x58,200);</em>
					</td>
				</tr>
			</table>

			<p><strong>Enumérations</strong></p>
			<table>
				<tr>
					<td></td>
					<td><strong>Syntaxe</strong></td>
					<td><strong>Description</strong></td>
				</tr>
				<tr>
					<td><img src="images/Enumerator_16x.png"></td>
					<td><strong>ModeRegister</strong></td>
					<td>
						<strong>Mode 0, Mode 1</strong><br>Commande indépendante des deux moteurs.<br><br>
						<strong>Mode 2, Mode 3</strong><br>-Speed 1 définit la vitesse médiane des deux moteurs. <br>-Speed 2 définit le diférentiel
						de vitesse à appliquer en + ou en - à chaque moteur.<br><br> Effet des paramètres de la méthode SetSpeedTurn : ValSpeed1
						et ValSpeed2 dans les différents modes. <br>
						<ul>
							<li><strong>Mode 0 </strong>(par défaut) <br> 0 (Full Reverse) 128 (Stop) 255 (Full Forward)</li>
							<li><strong>Mode 1</strong><br> -128 (Full Reverse) 0 (Stop) 127 (Full Forward).</li>
							<li><strong>Mode 2</strong><br> 0 (Full Reverse) 128 (Stop) 255 (Full Forward)</li>
							<li><strong>Mode 3</strong><br> -128 (Full Reverse) 0 (Stop) 127 (Full Forward)</li>
						</ul>
					</td>
				</tr>
			</table>

			<p><strong>Propriétés</strong></p>
			<table>
				<tr>
					<td></td>
					<td><strong>Syntaxe</strong></td>
					<td><strong>Description</strong></td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Speed1</strong></td>
					<td>Retourne la consigne de vitesse du moteur 1. Octet non signé. <br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("Speed1=" + MD25.Speed1.ToString());</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Speed2Turn</strong></td>
					<td>
						En cours de rédaction.
						<ul>
							<li>
								Modes 0 (le seul implémenté actuellement) et 1: Retourne la consigne de vitesse du moteur 2. Octet non signé. <br>
								<strong>Exemple</strong><br>
								<em>Debug.Print("Speed2=" + MD25.Speed2Turn.ToString());</em><br>
							</li>
							<li>
								Modes 2 et 3 : Retourne la consigne de rotation appliquée aux moteurs 1 et 2.
							</li>
						</ul>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Encoder1</strong></td>
					<td>Retourne la valeur de l'encodeur 1 (calculée à partir des registres Enc1a,b,c et d). Mot de 32bits signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("Codeur 1=" + MD25.Encoder1.ToString());</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Encoder2</strong></td>
					<td>Retourne la valeur de l'encodeur 2 (calculée à partir des registres Enc2a,b,c et d). Mot de 32bits signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("Codeur 2=" + MD25.Encoder2.ToString());</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Battery</strong></td>
					<td>Retourne la tension d'alimentation (x10) de la carte en (V). Octet non signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("Tension=" + ((Single)MD25.Battery / 10).ToString("N1") + "V");</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Current1</strong></td>
					<td>Retourne l'intensité du moteur 1 en (A). Octet non signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("I_moteur 1=" + MD25.Current1.ToString());</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Current2</strong></td>
					<td>Retourne l'intensité du moteur 2 en (A). Octet non signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("I_moteur 2=" + MD25.Current2.ToString());</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>SoftRev</strong></td>
					<td>Retourne le numéro de version du logiciel de la carte MD25. Octet non signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("Vers.=" + MD25.SoftRev.ToString());</em>

					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>AccelerationRate</strong></td>
					<td>Fixe ou retourne l'accélération programmée lors d'un changement de vitesse. Octet non signé.<br><br>
						<strong>Exemple</strong><br> // Pour connaître la valeur de l'accélération <br>
						<em>Debug.Print("Acceleration=" + MD25.AccelerationRate.ToString());</em> <br> // Pour fixer la valeur de l'accélération
						<br>
						<em>byte MD25.AccAccelerationRate = 1;</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Mode</strong></td>
					<td>Retourne le mode de fonctionnement de la carte 0,1,2 ou 3. Octet non signé.<br><br>
						<strong>Exemple</strong><br> // Pour connaitre le mode de fonctionnement de la carte <br>
						<em>Debug.Print(Mode=" + MD25.Mode.ToString());</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>Command</strong></td>
					<td>Fixe ou retourne le contenu du registre de commande. Octet non signé.<br><br>
						<strong>Exemple</strong><br>
						<em>Debug.Print("" + );</em>
					</td>
				</tr>
				<tr>
					<td><img src="images/Property_20x.png"></td>
					<td><strong>TransactionTimeOut</strong></td>
					<td>Fixe ou retourne le temps (en ms) accordé à la transaction avant la génération d'une System.IO.Exception. 1000ms par
						défaut. <br> Type : ushort
						<br><br>
						<strong>Exemples</strong><br> // Pour régler la durée maximum d'une transaction à 200ms. <br>
						<em>MD25.TransactionTimeOut = 200; </em> <br> // Pour connaître la durée maximum accordée à une transaction <br>
						<em> ushort time = MD25.TransactionTimeOut;</em>
					</td>
				</tr>
			</table>

			<p><strong>Méthodes publiques</strong></p>
			<table>
				<tr>
					<td></td>
					<td><strong>Syntaxe</strong></td>
					<td><strong>Description</strong></td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>void GetAllRegister()</strong></td>
					<td>Lecture des 16 registres de la carte MD25.</td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>void RazEncoders()</strong></td>
					<td>Remise à zéro des deux encodeurs.</td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>void SetMode</strong>(<strong>ModeRegister</strong> <em>valmode</em>)</td>
					<td>Définit le mode de fonctionnnement de la carte <em>valmode=</em>0, 1,2 ou 3.</td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>void SetSpeedTurn</strong>(<strong>byte</strong> <em>ValSpeed1</em>, <strong>byte</strong> <em>ValSpeed2Turn</em>)</td>
					<td>Règle la vitesse des moteurs.</td>
				</tr>
				<tr>
					<td><img src="images/Method_16x.png"></td>
					<td><strong>void StopMotor()</strong></td>
					<td>Arrêt des deux moteurs.</td>
				</tr>
			</table>
		</section>
	</div>

	<!-- FOOTER  -->
	<div id="footer_wrap" class="outer">
		<footer class="inner">
			<p class="copyright">Description de la classe MD25 développée en C# sous .NETMF 4.3 pour les cartes Netduino, et FEZ (PANDA, COBRA...) maintained
				by <a href="https://github.com/WebGE">WebGE</a></p>
			<p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
		</footer>
	</div>
</body>

</html>